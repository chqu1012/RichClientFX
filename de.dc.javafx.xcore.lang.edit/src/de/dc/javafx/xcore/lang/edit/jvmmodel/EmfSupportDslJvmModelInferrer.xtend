/*
 * generated by Xtext 2.17.0
 */
package de.dc.javafx.xcore.lang.edit.jvmmodel

import com.google.inject.Inject
import de.dc.javafx.efxclipse.runtime.EMFModelView
import de.dc.javafx.efxclipse.runtime.command.CommandStackImpl
import de.dc.javafx.efxclipse.runtime.model.IEmfManager
import de.dc.javafx.xcore.lang.edit.emfSupportDsl.AddContextMenu
import de.dc.javafx.xcore.lang.edit.emfSupportDsl.Model
import de.dc.javafx.xcore.lang.lib.AbstractApplication
import javafx.scene.Parent
import javafx.scene.control.TreeItem
import org.eclipse.emf.common.command.Command
import org.eclipse.emf.ecore.change.util.ChangeRecorder
import org.eclipse.emf.edit.command.AddCommand
import org.eclipse.emf.edit.domain.AdapterFactoryEditingDomain
import org.eclipse.emf.edit.domain.EditingDomain
import org.eclipse.emf.edit.provider.ComposedAdapterFactory
import org.eclipse.emf.edit.provider.ReflectiveItemProviderAdapterFactory
import org.eclipse.emf.edit.provider.resource.ResourceItemProviderAdapterFactory
import org.eclipse.xtext.xbase.interpreter.impl.XbaseInterpreter
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder
import org.eclipse.fx.emf.edit.ui.EAttributeCellEditHandler
import javafx.event.ActionEvent
import org.eclipse.emf.edit.command.DeleteCommand
import org.eclipse.emf.edit.command.CopyToClipboardCommand

class EmfSupportDslJvmModelInferrer extends AbstractModelInferrer {

	@Inject extension JvmTypesBuilder
	@Inject XbaseInterpreter xbaseInterpreter;
	
	def dispatch void infer(Model element, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		for(model : element.ecore){
			val path = model.packagePath.replaceAll("\'", "").replace("\"", "")
			val name = model.name
			
	 		acceptor.accept(element.toClass(path+'.Base'+name+'Manager')[
	 			superTypes += IEmfManager.typeRef(model.rootType)
	 			
	 			members += model.toField('root', model.rootType)
	 			members += model.toField('editingDomain', EditingDomain.typeRef)
	 			members += model.toField('adapterFactory', ComposedAdapterFactory.typeRef)
	 			members += model.toField('changeRecorder', ChangeRecorder.typeRef)
	 			members += model.toField('commandStack', CommandStackImpl.typeRef)

	 			members += model.toConstructor[
	 				body = '''
					adapterFactory = new «ComposedAdapterFactory»(«ComposedAdapterFactory».Descriptor.Registry.INSTANCE);
					adapterFactory.addAdapterFactory(new «model.modelItemProviderAdapterFactory»());
					adapterFactory.addAdapterFactory(new «ResourceItemProviderAdapterFactory»());
					adapterFactory.addAdapterFactory(new «ReflectiveItemProviderAdapterFactory»());
					
					commandStack = new «CommandStackImpl»();
					editingDomain = new «AdapterFactoryEditingDomain»(adapterFactory, commandStack);
					changeRecorder = new «ChangeRecorder»();
	 				'''
	 			]
	 			
	 			members += model.toMethod('getRoot', model.rootType)[
	 				body = '''
	 				if (root==null) {
	 				  root = «model.modelFactory».eINSTANCE.create«model.rootType.simpleName»();
	 				}
	 				return root;
	 				'''
	 			]
	 			members += model.toGetter('editingDomain', EditingDomain.typeRef)
	 			members += model.toGetter('adapterFactory', ComposedAdapterFactory.typeRef)
	 			members += model.toGetter('changeRecorder', ChangeRecorder.typeRef)
	 			members += model.toGetter('commandStack', CommandStackImpl.typeRef)
	 		])
	 		
	 		acceptor.accept(element.toClass(path+'.Base'+name+'View')[
	 			superTypes += EMFModelView.typeRef(model.rootType)
	 			
	 			members += model.toConstructor[
	 				parameters += model.toParameter('manager', IEmfManager.typeRef(model.rootType))
	 				body = '''
					super(manager);
					
					«EditingDomain» editDomain = manager.getEditingDomain();
					
					// add edit support
					treeView.setEditable(true);
					«FOR editable : model.editables»
					treeCellFactory.addCellEditHandler(new «EAttributeCellEditHandler»(«model.modelPackage».eINSTANCE.get«editable.name»(), editDomain));
					«ENDFOR»
	 				'''
 				]
 				
 				model.contextMenus.forEach[menu|
					if(menu instanceof AddContextMenu){
						val addMenu = menu as AddContextMenu
						members += model.toMethod('get'+menu.id+'Id', Integer.typeRef)[
							body = '''return «model.modelPackage».«addMenu.createType.simpleName.toUpperCase»;'''
						]
						
						members += model.toMethod('create'+menu.id, addMenu.createType)[
							body = '''return «model.modelFactory».eINSTANCE.create«addMenu.createType.simpleName»();'''
						]
					}
				]
				
				members += model.toMethod('onNewMenuItemClicked', typeRef(Void.TYPE))[
					annotations += model.toAnnotation(Override)
					parameters += model.toParameter("action", ActionEvent.typeRef)
					body = '''
				 	«TreeItem»<Object> selection = treeView.getSelectionModel().getSelectedItem();
				 	if (selection!=null) {
				 		Object owner = selection.getValue();
				 		«Command» command = null;
				 		«FOR menu : model.contextMenus»
				 		«IF menu instanceof AddContextMenu»
				 		«val addMenu = menu as AddContextMenu»
				 		if (owner instanceof «menu.parentType») {
				 			command = «AddCommand».create(editingDomain, owner, get«addMenu.id»Id(), create«addMenu.id»());
				 		}
				 		«ELSE»
				 		
				 		«ENDIF»
				 		«ENDFOR»
				 		if(command.canExecute()){
				 			manager.getCommandStack().execute(command);
				 		}
				 		selection.setExpanded(true);
				 	}
					'''
				]
				
				members += model.toMethod('onDeleteMenuItemClicked', typeRef(Void.TYPE))[
					annotations += model.toAnnotation(Override)
					parameters += model.toParameter("action", ActionEvent.typeRef)
					body = '''
				 	«TreeItem»<Object> selection = treeView.getSelectionModel().getSelectedItem();
				 	if (selection!=null) {
				 		«Command» command = «DeleteCommand».create(editingDomain, selection.getValue());
				 		if(command.canExecute()){
				 			manager.getCommandStack().execute(command);
				 		}
				 	}
					'''
				]

				members += model.toMethod('onCopyMenuItemClicked', typeRef(Void.TYPE))[
					annotations += model.toAnnotation(Override)
					parameters += model.toParameter("action", ActionEvent.typeRef)
					body = '''
					TreeItem»<Object> selection = treeView.getSelectionModel().getSelectedItem();
					if(selection!=null){
					 	«Command» command = «CopyToClipboardCommand».create(editingDomain, selection.getValue());
					 	if(command.canExecute()){
					 		manager.getCommandStack().execute(command);
					 	}
					}
					'''
				]
	 		])
	 		
	 		if(model.generateDemo){
		 		acceptor.accept(element.toClass(path+'.Base'+name+'ViewApplication')[
		 			superTypes += AbstractApplication.typeRef
		 			
		 			members += model.toMethod('getRoot', Parent.typeRef)[
		 				annotations += model.toAnnotation(Override)
		 				body = '''return getView(getManager());'''
	 				]
	 				
	 				members += model.toMethod('getManager', IEmfManager.typeRef(model.rootType))[
		 				body = '''return new Base«name»Manager();'''
	 				]

	 				members += model.toMethod('getView', EMFModelView.typeRef(model.rootType))[
		 				parameters += model.toParameter('manager', IEmfManager.typeRef(model.rootType))
		 				body = '''return new Base«name»View(manager);'''
	 				]
	 				
					members += element.toMethod("main", 'void'.typeRef)[
						static = true
						parameters += element.toParameter('args', String.typeRef.addArrayTypeDimension)
						body ='''launch(args);'''
					]
		 		])
	 		}
		}
	}
}
